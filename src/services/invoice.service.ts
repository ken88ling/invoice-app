import { Invoice, InvoiceListItem, InvoiceCalculations, InvoiceStatus } from '@/types/invoice'
import { CreateInvoiceInput, UpdateInvoiceInput, InvoiceItemInput } from '@/lib/validations/invoice'
import { InvoiceRepository } from '@/repositories/invoice.repository'
import { CustomerService } from './customer.service'
import { FindManyOptions } from '@/repositories/base.repository'

export class InvoiceService {
  private static repository = new InvoiceRepository()

  static async getInvoices(search?: string): Promise<InvoiceListItem[]> {
    const options: FindManyOptions = {}
    
    if (search) {
      options.search = search
    }

    return this.repository.findManyListItems(options)
  }

  static async getInvoice(id: string): Promise<Invoice> {
    const invoice = await this.repository.findUnique(id)
    
    if (!invoice) {
      throw new Error('Invoice not found')
    }

    return invoice
  }

  static async createInvoice(data: CreateInvoiceInput): Promise<Invoice> {
    // Verify customer exists
    await CustomerService.getCustomer(data.customerId)
    
    // Generate invoice number if not provided
    const invoiceNumber = data.number && data.number.trim() !== '' 
      ? data.number 
      : await this.repository.generateInvoiceNumber()
    
    // Calculate totals
    const calculations = this.calculateInvoiceTotals(data.items, data.taxRate)
    
    const invoiceData = {
      ...data,
      number: invoiceNumber,
      subtotal: calculations.subtotal,
      taxAmount: calculations.taxAmount,
      total: calculations.total,
    }

    return this.repository.create(invoiceData)
  }

  static async updateInvoice(id: string, data: UpdateInvoiceInput): Promise<Invoice> {
    // Verify invoice exists
    await this.getInvoice(id)
    
    // If customer is being changed, verify new customer exists
    if (data.customerId) {
      await CustomerService.getCustomer(data.customerId)
    }

    // Recalculate totals if items or tax rate changed
    if (data.items || data.taxRate !== undefined) {
      const currentInvoice = await this.getInvoice(id)
      const items = data.items || currentInvoice.items
      const taxRate = data.taxRate !== undefined ? data.taxRate : currentInvoice.taxRate
      
      const calculations = this.calculateInvoiceTotals(items, taxRate)
      
      data.subtotal = calculations.subtotal
      data.taxAmount = calculations.taxAmount
      data.total = calculations.total
    }

    return this.repository.update(id, data)
  }

  static async deleteInvoice(id: string): Promise<void> {
    // Verify invoice exists
    await this.getInvoice(id)
    
    // TODO: Add business logic checks (e.g., cannot delete paid invoices)
    
    await this.repository.delete(id)
  }

  static async getInvoicesByCustomer(customerId: string): Promise<InvoiceListItem[]> {
    // Verify customer exists
    await CustomerService.getCustomer(customerId)
    
    return this.repository.findByCustomer(customerId)
  }

  static calculateInvoiceTotals(items: InvoiceItemInput[], taxRate: number = 0): InvoiceCalculations {
    const subtotal = items.reduce((sum, item) => {
      const itemTotal = item.quantity * item.rate
      return sum + itemTotal
    }, 0)

    const taxAmount = subtotal * taxRate
    const total = subtotal + taxAmount

    return {
      subtotal: Number(subtotal.toFixed(2)),
      taxAmount: Number(taxAmount.toFixed(2)),
      total: Number(total.toFixed(2)),
    }
  }

  static calculateItemAmount(quantity: number, rate: number): number {
    return Number((quantity * rate).toFixed(2))
  }

  static async updateInvoiceStatus(id: string, status: InvoiceStatus): Promise<Invoice> {
    // Get current invoice to get customerId
    const currentInvoice = await this.getInvoice(id)
    return this.repository.update(id, { customerId: currentInvoice.customerId, status })
  }

  static async duplicateInvoice(id: string): Promise<Invoice> {
    const originalInvoice = await this.getInvoice(id)
    
    const duplicateData: CreateInvoiceInput = {
      customerId: originalInvoice.customerId,
      number: '', // Will be auto-generated by createInvoice
      issueDate: new Date(),
      dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days from now
      subtotal: originalInvoice.subtotal,
      taxRate: originalInvoice.taxRate,
      taxAmount: originalInvoice.taxAmount,
      total: originalInvoice.total,
      notes: originalInvoice.notes,
      items: originalInvoice.items.map(item => ({
        description: item.description,
        quantity: item.quantity,
        rate: item.rate,
        amount: item.amount,
      })),
    }

    return this.createInvoice(duplicateData)
  }
}